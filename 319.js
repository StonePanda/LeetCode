/**
 * @param {number} n
 * @return {number}
 */
// var bulbSwitch = function(n) {
//     let bulbs = new Array(n).fill(false)
//         // 第1轮改变，1-1=0，0+1=1，1+1=2
//         // 第2轮改变，2-1=1，1+2=3，3+2=5
//         // 第3轮改变，3-1=2，2+3=5
//         // 第k轮改变，k-1开始，每一个都是相加k
//     for (let i = 1; i <= n; i++) {
//         for (let j = i - 1; j <= n; j += i) {
//             bulbs[j] = !bulbs[j]
//         }
//     }
//     let result = 0
//     for (let i = 0; i < n; i++) {
//         if (bulbs[i]) {
//             result++
//         }
//     }
//     return result
// };
// 上面的代码在例子31/35的时候就执行出错，栈溢出了：
// 9999999

// 草草草！！虽然做的时候想到了是一道数学题！
// 但是程序员的真正奥义难道不是模拟吗？
// 为什么要花心思去想题目背后的数学意义啊？
// 这些为什么要让程序员来做啊！

// 所以来分析一下这道题的数学：
// 对于第i轮，i的倍数的灯泡都会被切换
// 那么对于第k个灯泡，它由几个约数，就会被切换几次
// 但是它的约束都是成对的，k有约数x，那么也就会有约数k/x
// 那么什么时候它有奇数个约束呢？当他是一个完全平方数的时候
// 比如9，是3的完全平方数，那么它就有奇数个约束，那么最后它肯定是亮着的
// 也就是我们要找的是，1-n的完全平方数的个数，也就是根号n

// 但是根号n涉及到浮点数运算，为了保证不出现精度问题，可以计算根号（n+1/2）
// 这样可以保证计算出来的结果向下取整在32位整数范围内一定正确
// 为什么？
// 看到有人说+0.000001也可以，先记住？


/**
 * @param {number} n
 * @return {number}
 */
var bulbSwitch = function(n) {
    return Math.floor(Math.sqrt(n + 1 / 2))
        // Math.floor()可以理解为向下取整
        // 返回小于或等于给定数字的最大整数
};