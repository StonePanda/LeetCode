/**
 * @param {number} n
 * @param {number} k
 * @return {number}
 */
var kInversePairs = function(n, k) {
    // 逆序对的定义不一定是i和j要挨在一起

    // 这个不看教程真地写不出来，但是总觉之前做过类似但是更简单的题目

    // 思路是对的，确实是需要动态规划的

    // 第一步，定义dp数组，dp[i][j]表示从1到i的数组，恰好拥有k个逆序对的不同的数组的个数

    // 然后，我们怎么考虑递推公式呢？
    // 怎么产生逆序对，我们用最简单的方式，从1到i里抽出一个字符把它放在最后的位置，就变成了1，2，k-1，k+1，k+2，i，k
    // 这样会产生多少个逆序对？i-k个，因为k和k+1到i的值产生了逆序对，也就是i-k个
    // 但是还有一部分逆序对,可以产生在1,2,k-1,k+1,k+2,i这一段数组里,那我们怎么看这段数组?
    // 因为逆序对实际上只和相对大小有关,我们把k+1,i这一段变成k,i-1,那么那个数组产生多少逆序对?
    // 就是j-i+k个,那么他们可能有多少个数组?dp[i-1][j-i+k]个数组
    // 对于dp[i][j]来说,可能有1到i-1个k
    // 那么:dp[i][j]=k从1到i-1的(dp[i-1][j-i+k])的和

    // 怎么会想到这一层呢?真神奇

    // 确定循环方向,i肯定是从1到n的, j肯定也是从0到k的,k在上面推到过了,是从1到i-1的

    // j==0的话,不管i为何值,dp[i][j]==1
    // i==0的话,其实是没有意义的
    // i==1的话,j>=1时,dp[i][j]==0

    // 然后再来列一下,如果n==3,k==1,那么dp[3][1]=dp[2][-2+1]+dp[2][-2+2]=1+1=2
    // 当j为负值的时候,相当于没有逆序对?
    const MOD = 1000000007

    let dp = new Array(n + 1)
    for (let i = 0; i < dp.length; i++) {
        dp[i] = new Array(k + 1).fill(0)
    }
    // 初始化
    for (let i = 0; i < dp.length; i++) {
        dp[i][0] = 1
    }
    // 下面这个写不写没什么区别
    // for(let j=1;j<dp[0].length;j++)
    // {
    //     dp[1][j]=0
    // }
    for (let i = 1; i < dp.length; i++) {
        for (let j = 1; j < dp[0].length; j++) {
            for (let k = 1; k <= i; k++) {
                if (j - i + k >= 0) {
                    dp[i][j] += dp[i - 1][j - i + k]
                }
                // 题目里说如果dp[i][j]太大,那么可以只返回
                // 对10的九次方+7取余的值
                if (dp[i][j] >= MOD) {
                    dp[i][j] -= MOD
                }
            }
        }
    }
    return dp[n][k]
};