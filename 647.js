/**
 * @param {string} s
 * @return {number}
 */
var countSubstrings = function(s) {
    // 第一感觉来写动规数组：dp[i]表示s[0,i-1]的回文子串的数目为dp[i]
    // 写递推公式：
    // dp[i]肯定是根据dp[i-1]推导而来的，分两种情况，nums[i-1]和nums[i-2]是否相等：
    // 其次如果新加进来的nums[i-1]如果和nums[0]相等的话，那么有可能和前面的组成回文字符串，也有可能没办法组成
    // 如果不相等的话，那肯定和之前的组不成回文字符串，所以dp[i]=dp[i-1]+1

    // 上面递推公式写不出来

    // 和我想得不一样，这道题用的是二维动规数组
    // 然后回想了一下上次的遇到那个我想用二维动规数组,但是答案却用的一维
    // 发现了一个规律,那就是这两道题目都可以用贪心做,用贪心去思考一遍,发现这个题目需要两个for循环遍历,即判断s[i,j]之间是不是回文
    // 但是上次那道题目用贪心算法做的时候就是,其实用不到双层for循环,所以用的是一维的动规数组

    // 所以这道题用二维的动规数组来思考一下:
    // dp[i][j]表示s[i,j]之间是不是回文字符串,true或者false
    // 突然从编辑距离的思路转到这样的二维动规数组有一些不适应
    // 那么dp[i][j]的递归公式,首先j-i==1的时候,dp[i][j]一定是true
    // 其次,如果dp[i-1][j-1]是true的时候,nums[i]==nums[j]为true,那么dp[i][j]也为true,否则为false
    // 如果这样写二维数组的话,i一定是要小于j的

    // 主要是递推公式：dp[i][j],dp[i-1][j]左边多出来一个字符


    // 不知道为什么，自己想递推公式的时候就乱卡卡，但是看了教程就豁然开朗
    // 看教程后的递推公式推导过程：
    // 分为两种情况：dp[i][j],s[i]和s[j]相等的时候，和不相等的时候：
    // 不相等比较好说，s[i]!=s[j]，dp[i][j]==false
    // 相等的时候：s[i][j],如果i==j,那肯定是s[i],那么dp[i][j]=true
    // 如果是j-i==1,那么肯定是aa这种情况，所以还是dp[i][j]==true
    // 如果是j-i>1,那么就变成了aXXXa这种情况，是不是回文子串，就要看XXX是不是，XXX是，就是，不是，就不是
    // 我当时是咋想的呢，我忘记了两边相同这个大前提，而且总是把中间那一串只取边上的一个值，不对称！
    // 上面>1的那种情况,dp[i][j]=dp[i+1][j-1]

    // 然后是初始化，都初始化为false这一点是可以的

    // 然后是遍历顺序：
    // 遍历顺序要看递推公式，i是从后往前推的，j是从前往后推的，但是还要满足i<=j
    let dp = Array(s.length)
    for (let i = 0; i < dp.length; i++) {
        dp[i] = Array(s.length).fill(false)
    }
    let result = 0
    for (let i = dp.length - 1; i >= 0; i--) {
        for (let j = 0; j < dp[0].length; j++) {
            if (i <= j) {
                if (s[i] != s[j]) {
                    dp[i][j] = false
                } else {
                    if (j - i <= 1) {
                        dp[i][j] = true
                        result++
                    } else {
                        if (dp[i + 1][j - 1]) {
                            dp[i][j] = true
                            result++
                        }
                    }
                }
            }
        }
    }
    return result
};

// 回文子串也是很经典的题目了！记住吧！